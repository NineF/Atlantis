堆排序:
	原地,时间复杂度为O(nlogn)


快速排序:
	平均情况下,时间复杂度为O(nlogn)

为什么快排的性能比堆排序好?
	1.堆排序的数据访问方式不友好,快排是顺序访问,堆排序是跳着访问,对CPU的缓存不友好
	2.对于相同的数据,在排序过程中,堆排序的数据交换次数比快排多.堆排序第一步是建堆,导致本来有序的数据会变成无序,降低了有序度


堆:
	一个完全二叉树
	堆中每个节点的值都必须大于等于(或小于等于)起子树中每一个节点的值
	
	堆化分为从上往下和从下往上两种
	往堆中插入和删除一个元素的时间复杂度为O(logn)

	建堆的时间复杂度为O(n),堆排序的时间复杂度为O(nlogn),堆排序不是一个稳定的排序
	
	重要应用:
		1.优先级队列
			--合并小文件:将小文件中的字符放入小顶堆,每次删除堆顶元素,然后从该小文件再取一个字符,堆插入和删除的时间复杂度为O(logn)
			--高性能定时器:避免每次都扫描任务列表,堆顶是下一个要执行的任务,可以获取到执行时间,然后设置间隔
		2.TopK
			--静态数据(数据确定,不会改变):维护一个k个数据的小顶堆,如果比堆顶数据大,就删除堆顶,然后将其插入堆中.遍历的时间复杂度为O(n),插入的时间复杂度为O(logn),最坏情况下的时间复杂度为O(nlogn)
			--动态数据(实时topK):一直维护一个k大小的小顶堆,数据添加进去集合时,就和堆比较
		3.求中位数
			--静态数据:直接排序获取
			--动态数据:维护一个小顶堆和大顶堆.大顶堆存储前半部分数据,小顶堆存储后半部分数据,并且,小顶堆中的数据都大于大顶堆中的数据.插入数据是,如果数据小于等于大顶堆的堆顶,则插入大顶堆;如果大于等于小顶堆的堆顶,则插入小顶堆.如果数据个数违反了规定,则将一个堆中的元素不停的移动到另一个堆中.由于涉及堆化,时间复杂度为O(logn),如果个数n为奇数,则大顶堆中为n/2+1个.





tip:
	1.完全二叉树比较适合用数组存储,不需要存储左右子节点的指针,单纯的通过下标访问
	2.堆排序用数组实现的话,最好序号从1开始,如果从0开始,会做一次加法运算






图
	图中的每个元素叫顶点,顶点之间的连接关系叫做边.一个顶点有多少条边,叫做度.
	对于有向图:有多少条边指向这个顶点,叫入度;以这个顶点为起点指向其他顶点,叫出度.
	

邻接矩阵存储方法
	底层依赖于一个二维数组,对于无向图,利用对角线分为上下两部分,利用一部分来存储;如果存储稀疏图,会存在大量的空间浪费.但是高效,方便计算.可以将图之间的

邻接表存储方法
	类似于hash中的拉链,每个顶点将指向的顶点形成一个链表.邻接表在使用起来会比矩阵更费时间.但是空间更省.为了避免链过长,为了提高查找效率,可以采用红黑树.跳表等结构来存储

广度优先搜索(BFS)
	利用队列存储每层要遍历的顶点.单独用个visited[]来存储是否访问,时间复杂度->O(V+E)->O(E),其中V为顶点,E为边,空间复杂度O(V)
深度优先搜索(DFS)
	采用递归(栈)来实现,单独设置一个found变量,当查找到数据后,全部返回.每条边最多会被访问两次,一次遍历,一次回退,时间复杂度为O(E),递归栈的最大深度也不会超过顶点的个数,空间复杂度为O(V)
	


字符串匹配
	BF算法(暴力匹配算法):
		就是挨个匹配比较,最坏的时间复杂度为O(n*m)
	PK算法(Rabin-Karp算法):
		将主串中的n-m+1个子串求hash,然后比较hash值是不是和模式串一致,这样虽然比较效率提高,但是计算hash的时候也会遍历子串中的每个字符.算法的整体效率并没有打的提高.
		为了提高hash计算子串hash值的效率,可以采用特有的hash算法.假设字符集只有k,那就用一个k进制来表示主串,如a~z含有26个,则用一个26进制来计算和表示.这样.计算hash的时候将子串当成26进制数字计算相加.并且,前后子串之间还有一定的规律:h[i] = 26*(h[i-1]-26^(m-1)*(s[i-1]-'a')) + (s[i+m-1]-'a');为了方便计算,也可以将k进制的次方存起来,节省计算时间.时间复杂度为:扫描一次主串就可以得到子串的hash,为O(n),比较需要比较n-m+1,为O(n),所以总时间复杂度为O(n)

	BM算法(Boyer-Moore):
		1.坏字符规则,从模式串的后往前匹配,如果遇到了坏字符,就移动si-xi位,si为坏字符对应的模式串的下标,xi为坏字符在模式串中的下标,如果不存在就为-1
		2.好后缀规则,把已经匹配好的后缀做为{u},然后在模式串中查询是否有另一个{u},为{u*},如果有,就将子串的{u*}和主串的{u}对齐;如果没有,将模式串移动到主串中{u}后面.这里要注意过度移动.
			--在模式串中,查找一个跟好后缀匹配的另一个子串
			--在好后缀的子串中,查找最长,能跟模式串的前缀子串匹配的后缀子串
	




